# frame_compare.py
"""
CODE GENERATED BY CHAT GPT 5
Frame comparison utilities: combined comparator (phash, whash, SSIM, ORB),
adaptive threshold computation, scene-gap detection, and debug image export.

Dependencies:
  - pillow
  - imagehash
  - opencv-python (cv2)
  - scikit-image (optional, improves SSIM)
Install example:
  pip install Pillow ImageHash opencv-python scikit-image
"""

from PIL import Image
import imagehash
import os
import statistics
from typing import List, Optional, Tuple, Dict

# optional SSIM
try:
    from skimage.metrics import structural_similarity as ssim
    import numpy as np
    HAVE_SSIM = True
except Exception:
    HAVE_SSIM = False

# optional ORB via OpenCV
try:
    import cv2
    HAVE_CV2 = True
except Exception:
    HAVE_CV2 = False

DEFAULT_HASH_SIZE = 8


def _open_gray_resize(path: str, resize_to: Tuple[int, int] = (320, 180)) -> Optional[Image.Image]:
    try:
        img = Image.open(path).convert("L")
        img = img.resize(resize_to, Image.BICUBIC)
        return img
    except Exception:
        return None


def phash_from_path(path: str, hash_size: int = DEFAULT_HASH_SIZE, thumb: Tuple[int,int]=(320,180)):
    """Return imagehash.ImageHash or None."""
    try:
        img = _open_gray_resize(path, thumb)
        if img is None:
            return None
        return imagehash.phash(img, hash_size=hash_size)
    except Exception:
        return None


def whash_from_path(path: str, hash_size: int = DEFAULT_HASH_SIZE, thumb: Tuple[int,int]=(320,180)):
    try:
        img = _open_gray_resize(path, thumb)
        if img is None:
            return None
        return imagehash.whash(img, hash_size=hash_size)
    except Exception:
        return None


def ssim_score_paths(pa: str, pb: str, thumb=(320, 180)) -> Optional[float]:
    if not HAVE_SSIM:
        return None
    try:
        ia = _open_gray_resize(pa, thumb)
        ib = _open_gray_resize(pb, thumb)
        if ia is None or ib is None:
            return None
        a = np.array(ia).astype(np.float32) / 255.0
        b = np.array(ib).astype(np.float32) / 255.0
        score = ssim(a, b, data_range=1.0)
        return float(score)
    except Exception:
        return None


def orb_match_ratio(pa: str, pb: str, resize=(320, 240)) -> Optional[float]:
    """Return ratio of good matches relative to min keypoints count. None if cv2 missing."""
    if not HAVE_CV2:
        return None
    try:
        a = cv2.imread(pa, cv2.IMREAD_GRAYSCALE)
        b = cv2.imread(pb, cv2.IMREAD_GRAYSCALE)
        if a is None or b is None:
            return None
        ah = cv2.resize(a, resize)
        bh = cv2.resize(b, resize)
        orb = cv2.ORB_create(500)
        kp1, des1 = orb.detectAndCompute(ah, None)
        kp2, des2 = orb.detectAndCompute(bh, None)
        if des1 is None or des2 is None or len(kp1) == 0 or len(kp2) == 0:
            return 0.0
        bf = cv2.BFMatcher(cv2.NORM_HAMMING)
        matches = bf.knnMatch(des1, des2, k=2)
        good = 0
        for m_n in matches:
            if len(m_n) < 2:
                continue
            m, n = m_n
            if m.distance < 0.75 * n.distance:
                good += 1
        denom = max(1, min(len(kp1), len(kp2)))
        return float(good) / float(denom)
    except Exception:
        return None


def compare_frames_combined(pa: str, pb: str, hash_size: int = DEFAULT_HASH_SIZE,
                            thumb=(320, 180)) -> Dict:
    """
    Compare two frames with a combined strategy.
    Returns dict with:
      - 'match' : bool (True = same)
      - metrics: phash_dist, whash_dist, ssim, orb_ratio
    Decision is automatic and adaptive:
      - if SSIM available and >= 0.95 => same
      - else if phash_dist <= phash_thresh AND whash_dist <= phash_thresh => same
      - else if orb_ratio >= 0.35 and ssim >= 0.90 => same
      - else different
    phash_thresh is derived from hash_size (looser for small hashes).
    """
    # compute hashes
    ph_a = phash_from_path(pa, hash_size=hash_size, thumb=thumb)
    ph_b = phash_from_path(pb, hash_size=hash_size, thumb=thumb)
    wh_a = whash_from_path(pa, hash_size=hash_size, thumb=thumb)
    wh_b = whash_from_path(pb, hash_size=hash_size, thumb=thumb)
    ph_dist = 999 if ph_a is None or ph_b is None else int(ph_a - ph_b)
    wh_dist = 999 if wh_a is None or wh_b is None else int(wh_a - wh_b)
    ssim_v = ssim_score_paths(pa, pb, thumb=thumb) if HAVE_SSIM else None
    orb_v = orb_match_ratio(pa, pb) if HAVE_CV2 else None

    # derive adaptive phash threshold baseline
    phash_thresh = max(6, min(24, int(round(hash_size * 1.5 + 6))))  # heuristic baseline

    # decision rules
    match = False
    if ssim_v is not None and ssim_v >= 0.95:
        match = True
    elif ph_dist <= phash_thresh and wh_dist <= phash_thresh:
        match = True
    elif orb_v is not None and orb_v >= 0.35 and (ssim_v is None or ssim_v >= 0.90):
        match = True

    return {"match": match, "ph": ph_dist, "wh": wh_dist, "ssim": ssim_v, "orb": orb_v, "ph_thresh": phash_thresh}


# ------- sequence utilities -------

def phash_sequence_from_dir(directory: str, ext=('jpg', 'jpeg', 'png'), hash_size: int = DEFAULT_HASH_SIZE, thumb=(320,180)):
    files = sorted([f for f in os.listdir(directory) if os.path.isfile(os.path.join(directory, f)) and f.lower().split('.')[-1] in ext])
    res = []
    for f in files:
        path = os.path.join(directory, f)
        res.append(phash_from_path(path, hash_size=hash_size, thumb=thumb))
    return res


def adj_frame_hash_diffs(hashes) -> List[int]:
    diffs = []
    prev = None
    for h in hashes:
        if prev is not None and prev is not None and h is not None:
            try:
                diffs.append(int(h - prev))
            except Exception:
                diffs.append(0)
        elif prev is not None:
            diffs.append(0)
        prev = h
    return diffs


def adaptive_phash_threshold_from_sequences(hA, hB):
    diffs = adj_frame_hash_diffs(hA) + adj_frame_hash_diffs(hB)
    if not diffs:
        return 12
    m = statistics.mean(diffs)
    s = statistics.pstdev(diffs) if len(diffs) > 1 else 0.0
    thresh = int(round(m + 2.0 * s))
    thresh = max(6, min(24, thresh))
    return thresh


def best_shift_count_matches(hA, hB, max_shift, phash_thresh):
    n = len(hA); m = len(hB)
    best_shift = 0; best_count = -1
    for shift in range(-max_shift, max_shift + 1):
        if shift >= 0:
            a0 = 0; b0 = shift
        else:
            a0 = -shift; b0 = 0
        overlap = min(n - a0, m - b0)
        if overlap <= 0:
            continue
        cnt = 0
        for i in range(overlap):
            ha = hA[a0 + i]; hb = hB[b0 + i]
            if ha is None or hb is None:
                continue
            try:
                if int(ha - hb) <= phash_thresh:
                    cnt += 1
            except Exception:
                pass
        if cnt > best_count:
            best_count = cnt; best_shift = shift
    return best_shift, best_count


def aligned_same_array(hA, hB, shift, phash_thresh):
    n = len(hA); m = len(hB)
    if shift >= 0:
        a0 = 0; b0 = shift
    else:
        a0 = -shift; b0 = 0
    overlap = min(n - a0, m - b0)
    same = []
    for i in range(overlap):
        ha = hA[a0 + i]; hb = hB[b0 + i]
        if ha is None or hb is None:
            same.append(False)
        else:
            try:
                same.append(int(ha - hb) <= phash_thresh)
            except Exception:
                same.append(False)
    return same


def find_contiguous_true_blocks(binary: List[bool], min_len: int) -> List[Tuple[int,int]]:
    blocks = []
    s = None
    for i, v in enumerate(binary):
        if v:
            if s is None:
                s = i
        else:
            if s is not None:
                if i - s >= min_len:
                    blocks.append((s, i - 1))
                s = None
    if s is not None:
        if len(binary) - s >= min_len:
            blocks.append((s, len(binary) - 1))
    return blocks


def find_gap_from_same_array(same: List[bool], required_before_blocks: int, required_after_blocks: int, min_block_len: int):
    blocks = find_contiguous_true_blocks(same, min_block_len)
    if not blocks:
        return None
    for i in range(len(blocks)):
        for j in range(i+1, len(blocks)):
            before_count = i + 1
            after_count = len(blocks) - j
            if before_count >= required_before_blocks and after_count >= required_after_blocks:
                gap_start = blocks[i][1] + 1
                gap_end = blocks[j][0] - 1
                if gap_start <= gap_end:
                    return (gap_start, gap_end)
    # fallback - longest false run with sufficient surrounding trues
    longest = (0, -1)
    s = None
    for idx, val in enumerate(same):
        if not val:
            if s is None:
                s = idx
        else:
            if s is not None:
                if idx - s > longest[1] - longest[0] + 1:
                    longest = (s, idx - 1)
                s = None
    if s is not None:
        if len(same) - s > longest[1] - longest[0] + 1:
            longest = (s, len(same) - 1)
    if longest[1] >= longest[0]:
        before_true = sum(1 for k in range(0, longest[0]) if same[k])
        after_true = sum(1 for k in range(longest[1]+1, len(same)) if same[k])
        if before_true >= required_before_blocks and after_true >= required_after_blocks:
            return longest
    return None


def save_debug_images_for_gap(dst_dir: str, dirA: str, dirB: str, gap_idx_tuple: Tuple[int,int], before=5, after=5):
    """
    Save up to `before` images before gap start and `after` images after gap end from both dirA (main) and dirB (cut)
    into dst_dir for visual debugging. Filenames:
      debug_main_<gapstart>_<i>.jpg and debug_cut_<gapstart>_<i>.jpg
    """
    os.makedirs(dst_dir, exist_ok=True)
    a_files = sorted([f for f in os.listdir(dirA) if os.path.isfile(os.path.join(dirA, f))])
    b_files = sorted([f for f in os.listdir(dirB) if os.path.isfile(os.path.join(dirB, f))])
    s, e = gap_idx_tuple
    # gather indices to save (clamp)
    indices = list(range(max(0, s - before), s)) + list(range(s, min(len(a_files), e + 1))) + list(range(e + 1, min(len(a_files), e + 1 + after)))
    # trim to available
    # Save from both A and B if exist matching indices; if B is shifted, user should inspect
    saved = 0
    for idx in indices:
        if idx < len(a_files):
            src = os.path.join(dirA, a_files[idx])
            dst = os.path.join(dst_dir, f"debug_main_{s}_{idx}.jpg")
            try:
                Image.open(src).save(dst)
            except Exception:
                pass
        if idx < len(b_files):
            srcb = os.path.join(dirB, b_files[idx])
            dstb = os.path.join(dst_dir, f"debug_cut_{s}_{idx}.jpg")
            try:
                Image.open(srcb).save(dstb)
            except Exception:
                pass
        saved += 1
        if saved >= (before + after + 1) * 2:
            break